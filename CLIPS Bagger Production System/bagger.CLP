;;; An item represents something to be bagged.
(deftemplate item
  (slot name
		(type SYMBOL))
  (slot container-type
		(type SYMBOL))
  (slot size
		(allowed-values small medium large))
  (slot frozen
		(allowed-values no yes)
			   (default no)))
			   
;;; New bag names are generated by keeping a counter, which is initializes to
;;; zero, and when we need a new bag we increment the counter and create a
;;; symbol by appending to the "bag". This is a purely procedural approach.

(defglobal ?*prev-bag-number* = 0)

(deffunction new-bag-name ()
  (bind ?*prev-bag-number* (+ ?*prev-bag-number* 1))
  (sym-cat bag ?*prev-bag-number*))

;;; The current bag has a name as well as the number and size of its contents.
;;; For bagger, bags only have items of a particular size. Note that current-bag
;;; self initializes - name defaults to the next bag name, item-count defaults
;;; to zero, and item-size initializes to nil, which won't match any known size.

(deftemplate current-bag
  (slot name
		(type SYMBOL)
			   (default-dynamic (new-bag-name)))
  (slot item-count
		(type INTEGER)
			   (default 0))
(slot item-size
		(type SYMBOL)))

;;; Bagged facts represent items that have been bagged.
(deftemplate bagged
  (slot item-name
		(type SYMBOL))
  (slot bag-name
		(type SYMBOL)))

;;; The initial facts for Bagger. Note that the pepsi is commented out. This
;;; allows you to test rule B1.
(deffacts initial
  (current-bag)
  (item (name bread) (container-type plastic-bag) (size medium))
  (item (name glop) (container-type jar) (size small))
  (item (name granola) (container-type cardboard-box) (size large))
  (item (name ice-cream) (container-type cardboard-carton) (size medium) (frozen yes))
  (item (name potato-chips) (container-type plastic-bag) (size medium))
  ;;;(item (name pepsi) (container-type bottle) (size large))
)

;;; The rules of the sytem
(deffacts initial-facts
  (step check-order))

(defrule B0
=>
  (printout t "Bagger Production System" crlf)
  (set-strategy complexity)
  (assert (step check-order)))  
  
(defrule B1
  (step check-order)
  (item (name potato-chips))
  (not (item (name pepsi)))
=>
  (printout t "Do you want a bottle of Pepsi? ")
  (if (= (str-compare (upcase (readline t)) "YES") 0)
   then (assert (item (name pepsi) (container-type bottle) (size large)))))  
  
(defrule B2
  ?step-fact <- (step check-order)
=>
  (retract ?step-fact)
  (assert (step bag-large-items)))

(defrule B3
  (step bag-large-items)
  ?item-fact <- (item (name ?item-name) (container-type bottle) (size large))
  ?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count&:
(< ?item-count 6)))
=>
  (retract ?item-fact)
  (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
  (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))  

(defrule B4
  (step bag-large-items)
  ?item-fact <- (item (name ?item-name) (size large))
  ?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count&:
(< ?item-count 6)))
=>
  (retract ?item-fact)
  (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
  (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))  
  
(defrule B5
  (step bag-large-items)
  (item (name ?item-name) (size large))
  ?current-bag-fact <- (current-bag)
=>
  (retract ?current-bag-fact)
  (assert (current-bag)))
  
(defrule B6
  ?step-fact <- (step bag-large-items)
=>
  (retract ?step-fact)
  (assert (step bag-medium-items)))

(defrule B7
  (step bag-medium-items)
  ?item-fact <- (item (name ?item-name) (frozen yes) (size medium))
  (not (in-freezer-bag ?item-name))
=>
  (assert (in-freezer-bag ?item-name)))  

(defrule B8
  (step bag-medium-items)
  ?item-fact <- (item (name ?item-name) (size medium))
  ?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count)
(item-size ?item-size))
  (test (or (= ?item-count 0) (and (eq ?item-size medium) (< ?item-count 12))))
=>
  (retract ?item-fact)
  (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
  (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size medium)))
  
(defrule B9
  (step bag-medium-items)
  (item (name ?item-name) (size medium))
  ?current-bag-fact <- (current-bag)
=>
  (retract ?current-bag-fact)
  (assert (current-bag)))

(defrule B10
  ?step-fact <- (step bag-medium-items)
=>
  (retract ?step-fact)
  (assert (step bag-small-items)))

(defrule B11
  (step bag-small-items)
  ?item-fact <- (item (name ?item-name) (size small))
  ?current-bag-fact <- (current-bag (name ?bag-name) (item-count ?item-count)
(item-size ?item-size))
  (test (or (= ?item-count 0) (and (eq ?item-size small) (< ?item-count 18))))  
=>
  (retract ?item-fact)
  (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
  (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size small)))
  
(defrule B12
  (step bag-small-items)
  (item (name ?item-name) (size small))
  ?current-bag-fact <- (current-bag)
=>
  (retract ?current-bag-fact)
  (assert (current-bag)))

(defrule B13
  ?step-fact <- (step bag-small-items)
=>
  (retract ?step-fact)
  (assert (step done)))
  
(defrule log-bagged
  (declare (salience 10))
  (bagged (item-name ?item-name) (bag-name ?bag-name))
=>
  (printout t ?item-name " in " ?bag-name crlf))

(defrule log-in-freezer-bag
  (declare (salience 10))
  (in-freezer-bag ?item-name)
=>
  (printout t ?item-name " in freezer bag" crlf))  